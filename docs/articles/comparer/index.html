<!DOCTYPE html>
<html lang="ru-ru"><head>
    <title>Сравнение в C#</title>
    <link rel="icon"  type="image/x-icon" href="https://it-irokez.ru/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу." />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Сравнение в C#" />
    <meta property="og:image" content="https://it-irokez.ru/assets/images/logo.jpg" />
    <meta property="og:url" content="https://it-irokez.ru/articles/comparer/" />
    <meta property="og:description" content="Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу." />
    <style>
@import "https://fonts.googleapis.com/css2?family=Inconsolata&display=swap";:root{--cursor-visibility:hidden}html,body{width:100%;height:100%;overflow:auto;font-family:inconsolata,monospace;font-size:4vmin;line-height:4.1vmin;font-weight:400}body{margin:0;display:flex;flex-direction:row;justify-content:center;align-items:center}#content{min-width:82vmin;min-height:82vmin}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-track{border-radius:10px;box-shadow:inset 0 0 1px white}::-webkit-scrollbar-thumb{border-radius:10px;box-shadow:0 0 0 1px white}.cursor,#activity-title:after,#activity-content:after,#cd:after,#whoami:after,#cat:after,#tree:after{visibility:var(--cursor-visibility);content:"|";overflow:hidden;color:#fff;animation:blink 500ms linear infinite alternate}@keyframes blink{0%{opacity:0}100%{opacity:1}}@media only screen and (min-width:768px){body{font-size:2.5vmin;line-height:2.6vmin}#content{min-width:60vmin}}:root{--cursor-visibility:hidden}body{align-items:unset;overflow-y:scroll}#content{max-width:80vmin}pre{overflow-x:scroll;white-space:pre}@keyframes blink{0%{opacity:0}100%{opacity:1}}















    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
        
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



body{background:#1b1d1e}body #terminal{color:#BBBBBB}body #user{color:#23E298}body #dir{color:#D08010}body .Typewriter__cursor{color:#BBBBBB}a{color:#BBBBBB}

        

        
        
</style>



    <meta name="yandex-verification" content="355904de153d5134" />
    
    
    <script>window.yaContextCb = window.yaContextCb || []</script>
    <script src="https://yandex.ru/ads/system/context.js" async></script>

    <script type="text/javascript">
            (function (m, e, t, r, i, k, a) {
                m[i] = m[i] || function () { (m[i].a = m[i].a || []).push(arguments) };
                m[i].l = 1 * new Date();
                for (var j = 0; j < document.scripts.length; j++) { if (document.scripts[j].src === r) { return; } }
                k = e.createElement(t), a = e.getElementsByTagName(t)[0], k.async = 1, k.src = r, a.parentNode.insertBefore(k, a)
            })
            (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(90533415, "init", {
            clickmap: true,
            trackLinks: true,
            accurateTrackBounce: true
        });
    </script>
    <noscript>
        <div><img src="https://mc.yandex.ru/watch/90533415" style="position:absolute; left:-9999px;" alt="" /></div>
    </noscript>
    


</head><body><div id="content">
<div id="mobile-block">
  
<div id="yandex_rtb_R-A-1957258-10"></div>
<script>window.yaContextCb.push(()=>{
  Ya.Context.AdvManager.render({
    renderTo: 'yandex_rtb_R-A-1957258-10',
    blockId: 'R-A-1957258-10'
  })
})</script>
</div>
<div id="block">

<div id="yandex_rtb_R-A-1957258-2"></div>
<script>window.yaContextCb.push(()=>{
  Ya.Context.AdvManager.render({
    renderTo: 'yandex_rtb_R-A-1957258-2',
    blockId: 'R-A-1957258-2'
  })
})</script>
</div>
<meta property="og:title" content="Сравнение в C#"/>


    
    
    



    


    <span id='terminal'><h1 id='title'>Сравнение в C#</h1><span id='date'>Опубликовано: 20-11-2021</span></span>

    <span id=''><h2 id="предисловие">Предисловие</h2>
<p>Автор знает, как работает сравнение в C#, достаточно четко представляет разницу между семантикой значимого и ссылочного типов, однако все еще находит эту статью хорошей и позволяющей чуть глубже заглянуть под капот.</p>
<hr>
<p>Думаю, что каждый программист рано или поздно сталкивается с кодом, который работает «не так, как ты от него ожидаешь». Именно это и подтолкнуло меня к написанию следующей статьи, в которой я пытаюсь понять, почему Except в Linq работает так, как написан, а не так, как я хочу.</p>
<hr>
<p>Что, по вашему мнению, должен вывести следующий код:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FileInfo[] FirstDirrectoryFiles = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>FileInfo[] SecondDirrectoryFiles = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> FirstDirrectoryFiles.Except(SecondDirrectoryFiles))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(item.Name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Я вот предположил, что ничего, потому что Except должен вычитать множество (IEnumerable) правого аргумента из множества (IEnumerable) левого аргумента. Однако, вопреки моим ожиданиям я получил:</p>
<p><img src="/assets/images/comparer_1.png" alt=""></p>
<p>Вне всякого сомнения — это не похоже на пустое множество. Давайте попробуем разобраться в том, почему так получается (результат в .NET 5 и в .NET 6 — эквивалентен). Чтобы понять, почему так происходит, и что можно с этим сделать обратимся к документации метода <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.except?view=net-6.0">Except</a>. Там действительно написано, что этот метод «Находит разность множеств, представленных двумя последовательностями» и имеет две перегрузки:</p>
<ul>
<li><code>Except&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;)</code> Находит разность множеств, представленных двумя последовательностями, используя для сравнения значений компаратор проверки на равенство по умолчанию.</li>
<li><code>Except&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;, IEqualityComparer&lt;TSource&gt;)</code>. Находит разность множеств, представленных двумя последовательностями, используя для сравнения значений указанный компаратор IEqualityComparer<!-- raw HTML omitted -->.</li>
</ul>
<p>Обратите внимание на заявление о том, что для сравнения используется компаратор по умолчанию. Чтобы понять, почему наш код сработал именно так, как сработал, нам предстоит разобраться с поведением компаратора по умолчанию. Для этого я предлагаю проследовать на <a href="https://github.com/dotnet/runtime/">https://github.com/dotnet/runtime/</a> и проанализировать работу метода Except.</p>
<p>Наша <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L10">точка входа</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(<span style="color:#66d9ef">this</span> IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (first == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.first);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (second == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.second);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ExceptIterator(first, second, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Метод проверяет, что получил два объекта с ненулевым указателем и передает аргументы в <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L79">ExceptIterator</a>.</p>
<p>Строго говоря, можно было бы использовать и метод перегрузку, так как он работает буквально также:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(<span style="color:#66d9ef">this</span> IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second, IEqualityComparer&lt;TSource&gt;? comparer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (first == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.first);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (second == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.second);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ExceptIterator(first, second, comparer);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Почему перегрузка, а не параметр по умолчанию? Силами <a href="https://t.me/dotnettalks">сообщества</a> было вынесено предположение, что дело в <a href="https://coding.abel.nu/2014/07/adding-an-overload-is-a-breaking-change/">этом</a> и <a href="https://rules.sonarsource.com/csharp/RSPEC-2360">этом</a>.</p>
<p>Собственно код <a href="https://github.com/dotnet/runtime/blob/a7c69745a4e22757c69f65d2a750e2d6923e1186/src/libraries/System.Linq/src/System/Linq/Except.cs#L79">ExceptIterator</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> IEnumerable&lt;TSource&gt; ExceptIterator&lt;TSource&gt;(IEnumerable&lt;TSource&gt; first, IEnumerable&lt;TSource&gt; second, IEqualityComparer&lt;TSource&gt;? comparer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#66d9ef">set</span> = <span style="color:#66d9ef">new</span> HashSet&lt;TSource&gt;(second, comparer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (TSource element <span style="color:#66d9ef">in</span> first)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">set</span>.Add(element))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> element;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Из элементов второго аргумента создается <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs#L55">множество</a>. Элементы первого аргумента, которые удалось добавить в множество, возвращаются в качестве итератора.</p>
<p>Конструктор множества принимает интерфейс компаратора, который используется для сравнения элементов множества:</p>
<p><img src="/assets/images/comparer_2.png" alt=""></p>
<p>Конкретно в нашем случае компаратор равен null, поэтому проваливаемся в свойство Default обобщенного класса EqualityComparer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> HashSet(IEqualityComparer&lt;T&gt;? comparer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (comparer <span style="color:#66d9ef">is</span> not <span style="color:#66d9ef">null</span> &amp;&amp; comparer != EqualityComparer&lt;T&gt;.Default) <span style="color:#75715e">// first check for null to avoid forcing default comparer instantiation unnecessarily</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _comparer = comparer;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Special-case EqualityComparer&lt;string&gt;.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// hash buckets become unbalanced.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span>(T) == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        IEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (stringComparer <span style="color:#66d9ef">is</span> not <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _comparer = (IEqualityComparer&lt;T&gt;?)stringComparer;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/assets/images/comparer_3.png" alt=""></p>
<p><a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/EqualityComparer.CoreCLR.cs#L10">Тут</a>, на мой скромный взгляд, все очевидно:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualityComparer</span>&lt;T&gt; : IEqualityComparer, IEqualityComparer&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// To minimize generic instantiation overhead of creating the comparer per type, we keep the generic portion of the code as small</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// as possible and define most of the creation logic in a non-generic class.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> EqualityComparer&lt;T&gt; Default { [Intrinsic] <span style="color:#66d9ef">get</span>; } = (EqualityComparer&lt;T&gt;)ComparerHelpers.CreateDefaultEqualityComparer(<span style="color:#66d9ef">typeof</span>(T));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Комментарий гласит, что с целью минимизации накладных расходов на создание универсального экземпляра для каждого типа код обобщенных классов уменьшают насколько это возможно за счет переноса его логики в необобщенный класс (в нашем случае это ComparerHelpers).</p>
<p>Давайте же посмотрим на то, как <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L116">происходит процесс создания компаратора по умолчанию</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">object</span> CreateDefaultEqualityComparer(Type type)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Debug.Assert(type != <span style="color:#66d9ef">null</span> &amp;&amp; type <span style="color:#66d9ef">is</span> RuntimeType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">object?</span> result = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> runtimeType = (RuntimeType)type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (type == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">byte</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Specialize for byte so Array.IndexOf is faster.</span>
</span></span><span style="display:flex;"><span>        result = <span style="color:#66d9ef">new</span> ByteEqualityComparer();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Specialize for string, as EqualityComparer&lt;string&gt;.Default is on the startup path</span>
</span></span><span style="display:flex;"><span>        result = <span style="color:#66d9ef">new</span> GenericEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsAssignableTo(<span style="color:#66d9ef">typeof</span>(IEquatable&lt;&gt;).MakeGenericType(type)))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If T implements IEquatable&lt;T&gt; return a GenericEqualityComparer&lt;T&gt;</span>
</span></span><span style="display:flex;"><span>        result = CreateInstanceForAnotherGenericParameter((RuntimeType)<span style="color:#66d9ef">typeof</span>(GenericEqualityComparer&lt;<span style="color:#66d9ef">string</span>&gt;), runtimeType);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsGenericType)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Nullable does not implement IEquatable&lt;T?&gt; directly because that would add an extra interface call per comparison.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Instead, it relies on EqualityComparer&lt;T?&gt;.Default to specialize for nullables and do the lifted comparisons if T implements IEquatable.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (type.GetGenericTypeDefinition() == <span style="color:#66d9ef">typeof</span>(Nullable&lt;&gt;))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            result = TryCreateNullableEqualityComparer(runtimeType);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type.IsEnum)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The equality comparer for enums is specialized to avoid boxing.</span>
</span></span><span style="display:flex;"><span>        result = TryCreateEnumEqualityComparer(runtimeType);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result ?? CreateInstanceForAnotherGenericParameter((RuntimeType)<span style="color:#66d9ef">typeof</span>(ObjectEqualityComparer&lt;<span style="color:#66d9ef">object</span>&gt;), runtimeType);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Пойдем по порядку:</p>
<ol>
<li>
<p>Если тип аргумента byte, то возвращается компаратор специально для этого типа (ByteEqualityComparer)</p>
</li>
<li>
<p>Если это строка, то возвращается GenericEqualityComparer<!-- raw HTML omitted -->();</p>
</li>
<li>
<p>Если тип реализует IEquatable, то на основе GenericEqualityComparer<!-- raw HTML omitted --> возвращается GenericEqualityComparer для типа аргумента (даже не спрашивайте);</p>
</li>
<li>
<p>Если аргумент является универсальным типом (обобщением) и если этот универсальный тип Nullable&lt;&gt;,  <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L160">то на основе</a> NullableEqualityComparer<!-- raw HTML omitted -->  создается NullableEqualityComparer для типа аргумента;</p>
</li>
<li>
<p>Если аргумент – перечисление, <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/coreclr/System.Private.CoreLib/src/System/Collections/Generic/ComparerHelpers.cs#L179">то на основе</a> EnumEqualityComparer&lt;&gt; создается EnumEqualityComparer;</p>
</li>
<li>
<p>Во всех остальных случаях на основе ObjectEqualityComparer<!-- raw HTML omitted --> создается ObjectEqualityComparer.</p>
</li>
</ol>
<p>С помощью такого нехитрого кода (хотел было переписать через string builder, но, думаю, тут можно забить :D) попробуем понять, какой же из перечисленных случаев – наш:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
</span></span><span style="display:flex;"><span>FileInfo[] result1 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>FileInfo[] result2 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Type type = result1[<span style="color:#ae81ff">0</span>].GetType();
</span></span><span style="display:flex;"><span>Console.Write(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">$&#34;type == typeof(byte): {type == typeof(byte)}\n&#34;</span> +
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">$&#34;type == typeof(string): {type == typeof(string)}\n&#34;</span> +
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">$&#34;type.IsAssignableTo(typeof(IEquatable&lt;&gt;).MakeGenericType(type)): {type.IsAssignableTo(typeof(IEquatable&lt;&gt;).MakeGenericType(type))}\n&#34;</span> +
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">$&#34;type.IsGenericType: {type.IsGenericType}\n&#34;</span> +
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">$&#34;type.IsEnum: {type.IsEnum}\n\n&#34;</span>);
</span></span></code></pre></div><p>Что и следовало ожидать:</p>
<p><img src="/assets/images/comparer_4.png" alt=""></p>
<p>Это значит, что теперь наш путь лежит в <a href="https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/EqualityComparer.cs">ObjectEqualityComparer</a>. Вот, собственно, и он:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ObjectEqualityComparer</span>&lt;T&gt; : EqualityComparer&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span> Equals(T? x, T? y)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x != <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (y != <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> x.Equals(y);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (y != <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">int</span> GetHashCode([DisallowNull] T obj) =&gt; obj?.GetHashCode() ?? <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Equals method for the comparer itself.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span> Equals([NotNullWhen(<span style="color:#66d9ef">true</span>)] <span style="color:#66d9ef">object?</span> obj) =&gt;
</span></span><span style="display:flex;"><span>        obj != <span style="color:#66d9ef">null</span> &amp;&amp; GetType() == obj.GetType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">int</span> GetHashCode() =&gt;
</span></span><span style="display:flex;"><span>        GetType().GetHashCode();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ObjectEqualityComparer определяет метод Equals для двух объектов следующим образом:</p>
<ul>
<li>
<p>Объекты равны, если они оба null (что логично);</p>
</li>
<li>
<p>Объекты не равны, если только один из них null;</p>
</li>
<li>
<p>Если оба объекта не null, то их эквивалентность определяется методом Equals «левого» аргумента.</p>
</li>
</ul>
<p>Если обратиться к <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.io.fileinfo?view=net-6.0#methods">документации</a>, то можно увидеть, что у нашего класса FileInfo действительно есть метод Equals с пометкой «Унаследовано от Object». Что же, <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.object.equals?view=net-6.0#System_Object_Equals_System_Object_">туда</a> и лежит наш путь! Там в секции «комментарии» мы можем узнать, что:</p>
<blockquote>
<p>Если текущий экземпляр является ссылочным типом, Equals(Object) метод проверяет равенство ссылок, а вызов Equals(Object) метода эквивалентен вызову ReferenceEquals метода. Равенство ссылок означает, что сравниваемые объектные переменные ссылаются на один и тот же объект.</p>
</blockquote>
<p>На этом, казалось, можно было бы завершить наше путешествие, но давайте на последок придумаем, как заставить Except перестать показывать файлы в директории с моими документами.</p>
<p>Вариант из категории «пока так, потом пофикшу»:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
</span></span><span style="display:flex;"><span>FileInfo[] result1 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>FileInfo[] result2 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1
</span></span><span style="display:flex;"><span>                                 .Select(i =&gt; i.FullName)
</span></span><span style="display:flex;"><span>                                 .Except(result2.Select(i =&gt; i.FullName))
</span></span><span style="display:flex;"><span>                                 .Select(i =&gt; <span style="color:#66d9ef">new</span> FileInfo(i)))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(item.Name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Мы, по сути, вызываем Except для двух IEnumerate<!-- raw HTML omitted -->, а потом из результата снова собираем IEnumerate<!-- raw HTML omitted -->.</p>
<p>В свежем .net6 еще можно воспользоваться <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.exceptby?view=net-6.0">ExceptBy</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
</span></span><span style="display:flex;"><span>FileInfo[] result1 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>FileInfo[] result2 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1.ExceptBy(result2.Select(i =&gt; i.FullName), ks =&gt; ks.FullName))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(item.Name);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Этот код уже выглядит приятнее и даже избавляет нас от необходимости разбирать и снова собирать изначальный массив, но можно сделать это иначе.</p>
<p>Следующей идеей, посетившей мою голову, было унаследовать FileInfo и переопределить Equals, но, к сожалению, FileInfo является запечатанным (sealed) классом, а это значит, что он не может быть унаследован, так что этот путь нам отрезан.</p>
<p>Подойдем к вопросу с другой стороны. Вспомним, что Equals имеет перегрузку, принимающую вторым аргументом IEqualityComparer, что позволяет нам создать что-то вроде такого решения:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> documentsDir = <span style="color:#66d9ef">new</span> DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
</span></span><span style="display:flex;"><span>FileInfo[] result1 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>FileInfo[] result2 = documentsDir.GetFiles();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> (FileInfo item <span style="color:#66d9ef">in</span> result1.Except(result2, <span style="color:#66d9ef">new</span> CustomFileInfoComparer()))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(item.Name);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomFileInfoComparer</span> : IEqualityComparer&lt;FileInfo&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> IEqualityComparer&lt;FileInfo&gt;.Equals(FileInfo? lhv, FileInfo? rhv)
</span></span><span style="display:flex;"><span>       =&gt; lhv?.FullName == rhv?.FullName;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> IEqualityComparer&lt;FileInfo&gt;.GetHashCode(FileInfo obj) =&gt; obj.FullName.GetHashCode();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Это решение хорошо подходит в том случае, если дальше по коду вам предстоит еще хотя бы раз сравнивать IEnumerable<!-- raw HTML omitted -->.</p>
<p>На этом у меня все, надеюсь, что читатель нашел любопытным мой скромный труд.</p>
<p>Хочется выразить огромную благодарность моей жене за помощь в подготовке данного поста, а также сообществу <a href="https://t.me/dotnettalks">.NET Talks</a></p>
</span>



    </div>
    <style>
    h1 {
         
        color: #23E298;
        line-height: 6vmin;
        font-size: 6vmin;
    }


    #block {
        max-height: 350px;
        max-width: 1000px;
    }



    a,
    strong,
    ::marker,
    #date {
        color: #D08010;

    }

    table,
    td {
        border-collapse: collapse;
        border: 2px solid #D08010;
        max-width: 100%;
    }

    td {
        padding: 25px;
    }

    li a {
        font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
        font-size: 1em;
        line-height: 1.56;
    }

    li {
        padding-left: 2%;


    }

    a {
        text-decoration: none;
        font-size: 1em;
    }

    img {
        max-width: 100%;
        max-height: 80vh;
    }

    .navFull {
        background-color: #353535;
        line-height: 150%;
        font-family: "Courier New";
         
        display: inline;
        position: fixed;
        bottom: 0px;
        left: 0px;
        display: flex;
        flex-direction: row;
        justify-content: space-around;
        width: 100%;
        align-items: baseline;
        padding-top: 5px;
        padding: 10px;
        padding-bottom: 0px;
    }

     
    .navCredits {
        float: right;
        padding-right: 18px;
        padding-bottom: 10px;
         
    }

    #navigationBlock {}

    #content::after {
        content: "\a\a";
        white-space: pre;
    }

    
    #content {
        max-width: 80vw;
        font-size: 1.8vmax;
        line-height: 1.56;
        overflow-wrap: break-word;
        font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
        color: #BBBBBB;
    }
    @media only screen and (max-width : 1000px){
        #block {
            display: none;
        }
    }
    @media only screen and (min-width : 1000px){
        #mobile-block {
            display: none;
        }
    }
    @media only screen and (min-width : 1400px) {
        #content {
            font-size: 2.0vmin;
        }

    }
    li p {
        padding-left: 5%;
    }

    #coffee {
        background-color: #D08010;
        color: #fff;
        display: block;
        padding: 10px;
        border-width: 2px;
        border-radius: 10px;
    }

    @media only screen and (max-width:500px) {
        #content {
            padding-left: 2%;
        }

        body {
            font-size: 1.2em;
        }

        .navFull {
            line-height: 100%;
        }
    }
</style>

    
    <span class="navFull">
        
    
    

    
        

<div id="navigationBlock">
    <a href="/">Home</a>
    <span>&#8192;|&#8192;</span>
    <a href="./..">/articles/</a>
</div>

    

        
        <div class="navCredits">
            <a id="coffee" href="https://www.tinkoff.ru/cf/qTUdfLwVFO">Купить автору кофе</a>
        </div>
</span>


    

    

</body>

</html>